/*
    While I found it easier to encapsulate the logic of this element on it's own, I don't think it needs to have the styles injected in every shadow dom element.
    I'm already mildly bloating the dom and event cycle with many listeners, so let's not exacerbate issues.

    Find styles @ code-cube.scss

    (maybe), commiting to this file for now >.>
*/

@use "../../styles";

$baseDuration: 2.5s;

@function fadeDuration($incrementPercent) {
    @return $baseDuration + ($incrementPercent * $baseDuration)
};

:host {
    display: inline;
    font-weight: bold;
    color: styles.$secondary-green;
}

:host(.animate)
{
    animation-name: fadeInBlink;
    //animation-delay: 0;
    animation-duration: fadeDuration(0);
    animation-iteration-count: infinite;
    animation-direction: normal;
    animation-timing-function: linear;
}

:host([delay="0"]) { animation-delay: 0.1s * -1; animation-duration: fadeDuration(0); }
:host([delay="1"]) { animation-delay: 0.2s * -1; animation-duration: fadeDuration(0.1); }
:host([delay="2"]) { animation-delay: 0.3s * -1; animation-duration: fadeDuration(0.2); }
:host([delay="3"]) { animation-delay: 0.4s * -1; animation-duration: fadeDuration(0.2); }
:host([delay="4"]) { animation-delay: 0.5s * -1; animation-duration: fadeDuration(0.3); }
:host([delay="5"]) { animation-delay: 0.6s * -1; animation-duration: fadeDuration(0.3); }
:host([delay="6"]) { animation-delay: 0.7s * -1; animation-duration: fadeDuration(0.2); }
:host([delay="7"]) { animation-delay: 0.8s * -1; animation-duration: fadeDuration(0.2); }
:host([delay="8"]) { animation-delay: 0.9s * -1; animation-duration: fadeDuration(0.1); }
:host([delay="9"]) { animation-delay: 1.0s * -1; animation-duration: fadeDuration(0); }

@keyframes fadeInBlink {
     0% { opacity: 0; }
    30%, 70% { opacity: 1; }
    100% { opacity: 0; }
}
